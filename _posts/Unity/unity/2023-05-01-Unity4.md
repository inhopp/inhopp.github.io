---
title:  "[그래픽스 최적화] Forward/Deferred/Forward+ Rendering" 

categories:
  -  Unity
tags:
  - [Optimization]

toc: true
toc_sticky: true

date: 2023-05-01
last_modified_at: 2023-05-01
---


**Main Reference: <br>- [유니티 그래픽스 최적화](https://product.kyobobook.co.kr/detail/S000001888125)<br>[Unity Korea](https://www.youtube.com/watch?v=anz5bHVbeEY)**
{: .notice--warning}

<br>

# 🐳 Forward Rendering

| Forward Rendering | Lighting |
|:-:|:-:|
|![forward-v2](https://user-images.githubusercontent.com/96368476/235354147-ca16a15d-aef3-44a6-931c-888708b5ca1b.png)|![ligjting](https://user-images.githubusercontent.com/96368476/235354488-6a72388a-bf71-4c11-ba20-5875788902f9.gif)|  

Forward Rendering은 유니티가 전통적으로 사용해오던 렌더링 방식이다. Forward rendering을 사용하게 되면 각 오브젝트마다, 각 라이트마다 드로우콜을 날리게 된다. 사이즈가 큰 프레임 버퍼에 빛을 누적시키는 방식이기 때문에 메모리 대역폭 문제가 발생할 수 있고, 같은 픽셀을 다시 칠하는 오버드로우가 엄청나게 발생하게 된다. 또한 라이팅 연산을 오브젝트마다 수행하기 때문에 모든 lighting 연산이 끝나야만  depth test를 진행할 수 있다(낭비되는 계산 발생). 여기까지만 들으면 이런 걸 왜 쓰나 싶지만 GPU 메모리를 크게 사용하는 단계가 없기 때문에 하드웨어의 성능을 타지 않고, 모바일 게임에는 아주 적합하다.
 Universal Render Pipeline(URP)에 들어오면서는 각 light에 대해 multi-pass 방식이였던 lighting 연산이 single-pass로 개선되기도 했다(드로우콜 하나로 퉁).

<br>

## Light Component

| Mode | Render Mode |
|:-:|:-:|
|![1](https://user-images.githubusercontent.com/96368476/235356592-a6105fb6-9374-42b6-82ea-22e8ea5e03d6.png)|![2](https://user-images.githubusercontent.com/96368476/235356593-490795a9-7e25-4b9d-87f4-195c5fbbca95.png)|  

유니티 Light에 대해 조금 더 자세히 들어가보자. 우선 Light Component에서 Mode를 설정해줄 수 있다. Baked 모드의 경우 움직이지 않는 static한 litght들에게 적용할 수 있다. Baking이란 용어는 유니티를 하다보면 종종 마주치는데, 런타임에 연산하지 않고 미리 연산하여 저장하는 기법을 베이킹이라고 한다. 따라서 매 프레임 동적으로 움직이는 오브젝트들에는 적용할 수 없다. Realtime 모드의 경우 말 그대로 매 프레임 움직이는 라이트에 적용되는 모드이다. 런타임에 매 프레임 실시간으로 연산되어야 하므로 성능에 가장 큰 영향을 미친다. 이때 오른쪽 그림의 Render Mode에서 해당 라이트가 Important인지, Not Important인지 설정할 수 있다. 간단히 이야기하자면 Important로 설정한 라이트의 경우 per pixel 연산이 이루어지고, Not Important의 경우 per vertex 연산이 이루어진다. 당연하게도 per vertex 연산을 하게 되면 퀄리티가 떨어지지만 연산 비용은 훨씬 저렴해진다.



<br>



# 🐳 Deferred Rendering

![deferred-v2](https://user-images.githubusercontent.com/96368476/235361924-dd72ad46-1a94-4bf2-ac72-a18afe7a3239.png){: width="60%" height="70%"}

Deferred Rendering은 말 그대로 라이팅을 지연시킨 렌더링 방식이다. Forward Rendering처럼 오브젝트별로 라이팅을 계산하지 않고, 파이프라인의 맨 끝단에서 한 번에 처리한다. 따라서 라이팅 비용이 오브젝트에 비례하게 증가하지 않고(증가하기는 함), depth test를 라이팅 이전에 처리하기 때문에 화면에 출력되는 픽셀 연산만 하게된다. 결과적으로 매우 효율적인 연산이지만 GPU가 Multi Render Targets(MRT)기능을 지원해야 한다. Geometry Buffer(G-Buffer)라고도 불리는 MRT에는 씬에 등장하는 모든 오브젝트들의 geometry 정보들을 쑤셔 넣어야 한다. 따라서 굉장히 큰 메모리를 잡아먹으며 모바일 환경에서는 아직 적용하기 힘들다고 한다. 여담으로 모니터의 해상도가 올라가면서 PC환경 또한 라이팅 연산의 부담이 커졌다고 한다.

<br>

## Geometry Buffer

| Mode | Render Mode |
|:-:|:-:|
|![buffers](https://user-images.githubusercontent.com/96368476/235361926-4bae2b73-089b-4d95-b896-2b981b848cb8.png)|![3](https://user-images.githubusercontent.com/96368476/235363585-423bbf31-031e-4ee3-afe3-a851a484da6b.png)|  

Deferred Rendering은 G-Buffer의 데이터를 기반으로 라이팅 연산을 진행한다. 따라서 per pixel 연산만 지원되고, dynamic light도 효율적으로 처리할 수 있다. 하지만 depth test를 미리 진행하므로 불투명한 오브젝트나 스킨같은 경우는 forward rendering으로 다시 그려줘야 한다.



<br>


<br>
<br>


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}