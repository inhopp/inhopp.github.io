---
title:  "[따배씨++]Chapter9-1. 연산자 오버로딩"

categories:
  -  Cpp
tags:
  - [Programming]

toc: true
toc_sticky: true

date: 2022-06-28
last_modified_at: 2022-06-28
---

인프런에 있는 홍정모님의 **[홍정모의 따라하며 배우는 C++](https://www.inflearn.com/course/following-c-plus#)** 강의를 듣고 정리한 내용입니다.<br>
**[공부하는 식빵맘](https://ansohxxn.github.io/categories/cpp)** 님의 블로그를 참고했습니다.<br>
**[learncpp](https://www.learncpp.com/)** 교재 내용을 참고했습니다.
{: .notice--warning}

<br>



# 🚆 산술 연산자 오버로딩

``` cpp

#include <iostream>
using namespace std;

class A
{
public:
    int data_a = 10;
}

int main()
{
    A object1;
    A object2;

    cout << object1 + object2 << endl; // error

    return 0;
}

```

- C++의 경우 연산자의 오버로딩이 가능
- 클래스간의 연산을 정의해서 사용 가능
    - add()와 같은 함수를 정의 후 return하는 방식
    - 연산자 오버로딩 하는 방식
- 연산자간의 우선순위는 변하지 않음

<br>

> (return 타입) opeator (연산자) (parameters)

``` cpp

class A
{
public:
    int data_a = 10;
};

int operator + (const A &a, const A &b)
{
    return a.data_a + b.data_a;
}

int main()
{
    A object1;
    A object2;

    cout << object1 + object2 << endl; // 20

    return 0;
}

```

<br>

## 오버로딩 불가능한 연산자

- `? true:false` : 3항 연산자
- `::` : namespace범위 지정 연산자
- `sizeof` : 크기 연산자
- `.`, `.*` : 멤버 선택 (포인터)연산자


<br>

# 🚆 전역 함수 vs 멤버 함수

## 전역 함수로 오버로딩

``` cpp

class Cents
{
private:
    int m_cents;

public:
    Cents(int cents = 0) { m_cents = cents; }

    friend int operator+(const Cents &c1, const Cents &c2); // friendly 선언
};

int operator+(const Cents &c1, const Cents &c2)
{
    return c1.m_cents + c2.m_cents;
}

int main()
{
    Cents cents1(5);
    Cents cents2(7);

    cout << cents1 + cents2 << endl; // 12

    return 0;
}

```

- private 멤버에 접근해야 하는 경우 getter 함수 이용
- 또는 friendly 함수로 접근


<br>

## 멤버 함수로 오버로딩


``` cpp

class A
{
private:
    int data_a = 10;

public:
    int operator + (const A &a)
    {
    return data_a + a.data_a;
    }

};

int main()
{
    A object1;
    A object2;

    cout << object1 + object2 << endl; // 20

    return 0;
}

```

- 멤버 함수의 경우 this 파라미터가 생략되어 있음
- priave 변수 접근 가능



<br>

# 🚆 입출력 연산자 오버로딩

입출력 연산에 사용되는 `iostream` class는 다음 두 클래스를 상속받는 클래스이다.
- 입력을 담당하는 `istream`
- 출력을 담당하는 `ostream`

<br>

> 예를 들어 std::cout은 ostream의 객체. <br>사실은 모두 오버로딩 해둔 것

``` cpp

ostream& operator<<(bool& val);
ostream& operator<<(short& val);
ostream& operator<<(unsigned short& val);
ostream& operator<<(int& val);
ostream& operator<<(unsigned int& val);
ostream& operator<<(long& val);
ostream& operator<<(unsigned long& val);
ostream& operator<<(float& val);
ostream& operator<<(double& val);
ostream& operator<<(long double& val);
ostream& operator<<(void* val);
...

```

- 따라서 입출력 연산자를 멤버 함수로 선언하려면 istream/ostream 내부에서 해야 함
    - 전역함수로만 정의 가능!


<br>

``` cpp

class Point
{
private:
    double m_x, m_y, m_z;

public:
    Point(double x = 0.0, double y = 0.0, double z = 0.0)
        : m_x(x), m_y(y), m_z(z)
    {
    }

    friend std::ostream &operator<<(std::ostream &out, const Point &point)
    {
        out << "( " << point.m_x << ", " << point.m_y << ", " << point.m_z << " )";

        return out;
    }
};

int main()
{
    Point p1(0.0, 0.1, 0.2);
    Point p2(3.4, 1.5, 2.0);

    cout << p1 << " " << p2 << endl; // ( 0, 0.1, 0.2 ) ( 3.4, 1.5, 2 )

    return 0;
}

```

- << 연산자의 오버로딩이 클래스 내부에서 정의되어 있어도 전역 함수(friend 특이케이스)
- std::ostream 객체로 return 받아야 chaining 가능
- ostream 객체의 << 오버로딩 하는 방식

<br>
<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}