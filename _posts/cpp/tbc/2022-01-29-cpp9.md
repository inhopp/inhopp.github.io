---
title:  "[따배씨++]Chapter7-2. 함수"

categories:
  -  Cpp
tags:
  - [Cpp, Programming, 따배씨++]

toc: true
toc_sticky: true

date: 2022-01-29
last_modified_at: 2022-01-29
---

인프런에 있는 홍정모님의 **[홍정모의 따라하며 배우는 C++](https://www.inflearn.com/course/following-c-plus#)** 강의를 듣고 정리한 내용입니다.<br>
**[공부하는 식빵맘](https://ansohxxn.github.io/categories/cpp)** 님의 블로그를 참고했습니다.
{: .notice--warning}

<br>


# 🚆 함수 오버로딩

> 함수의 이름 중복 사용. 시그니쳐로 구분

``` cpp
void getRandom(int& x);
void getRandom(double& x);
```

- 시그니처란 변수의 타입, 변수의 갯수 
- 리턴 타입은 시그니처 아님!
- 어떤 함수가 호출될지는 컴파일 타임에 결정되어야 함



<br>



``` cpp
void print(unsigned int value);
void print(float value);
void print(const char* value);

int main()
{
	print(0);		// Error
	print('a');		// Error
	print(3.14);		// Error

	print(0u);			// OK
	print((unsigned int)'a');	// OK
	print("a");			// OK
	print(3.14f);			// OK

	return 0;
}
```

- 애매하면 컴파일러가 구분 못함
- 오버로딩 사용 시에는 타입 명시해주는게 안전
- char은 int로 넘어가네..



<br>



# 🚆 기본 값 설정 - Default Parameters

``` cpp
int func_1(int x = 1, int y = 1, int z = 2) {};		// OK

int func_2(int x, int y, int z = 2) {};			// OK
int func_3(int x = 1, int y, int z) {};			// Error
```

- 기본 값이 없는 변수는 왼쪽에 있어야 함
- 선언 & 정의 나눌 시 둘 중 한 곳에서만 기본값 설정
  - 보통은 헤더파일에 선언하면서 기본 값 설정



<br>



# 🚆 함수 포인터

> 함수도 메모리 주소 갖고 있다 → 포인터 사용 가능

<br>

``` cpp
int func(int x)
{
	return x;
}


int main()
{
	cout << func << endl;	// 00007FF72CAD143D 출력 (함수의 주소)

	int(*funcptr)(int) = func;
	cout << funcptr(5) << endl;	// 5 출력

	return 0;
}
```

- `문법 : (리턴타입)(*포인터 이름)(파라미터) = 함수`
- `funcptr = func2`
  - 포인터는 다른 함수 지정할 수도 있음
  - 리턴 타입, 파라미터 타입, 파라미터 갯수 같아야 함



<br>


## 함수 포인터 예시 - 사용 전


``` cpp
void printNumbers(const array<int, 10>& my_arr, bool print_even)
{
	for (auto element : my_arr)
	{
		if (print_even && element % 2 == 0) cout << element;
		if (!print_even && element % 2 == 1) cout << element;
	}
	cout << endl;
}


int main()
{
	std::array<int, 10> my_arr{ 0,1,2,3,4,5,6,7,8,9 };

	printNumbers(my_arr, true);	// 짝수 원소만 출력
	printNumbers(my_arr, false);	// 홀수 원소만 출력

	return 0;
}
```

- 버튼 (true/false, 0/1/2/...)을 만들어 각각 기능 구현

<br>



## 함수 자체를 파라미터로 넘기기 - 사용 후

``` cpp
bool isEven(const int& number)
{
	if (number % 2 == 0) return true;
}

bool isOdd(const int& number)
{
	if (number % 2 == 1) return true;
}

void printNumbers(const array<int, 10>& my_arr, bool(*check_func)(const int&))
{
	for (auto element : my_arr)
	{
		if (check_func(element) == true) cout << element;
	}
	cout << endl;
}

int main()
{
	std::array<int, 10> my_arr{ 0,1,2,3,4,5,6,7,8,9 };

	printNumbers(my_arr, isEven);	// 짝수 원소만 출력
	printNumbers(my_arr, isOdd);	// 홀수 원소만 출력

	return 0;
}
```


<br>


## 함수 포인터 사용 TIP

**1. using**

``` cpp
using check_func_t = bool(*)(const int&);
check_func_t funcptr = isEven;
```

<br>

**2. typedef**

``` cpp
typedef bool(*check_func_t)(const int&);
check_func_t funcptr = isEven;
```

<br>

**3. std::function**

``` cpp
std::function<bool(const int&)> funcptr = isEven;
```

- `#include \<functional>`  : C++11에 추가
- `문법 : std::function<리턴타입(파라미터)> 변수 이름 = 함수`
- 함수 포인터 대신 function 기능도 많이 쓴다고 함

<br>
<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}