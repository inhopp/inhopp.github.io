---
title:  "Chapter10. 가상 메모리 관리(1)" 

categories:
  -  OS
tags:
  - [CS, OS]

toc: true
toc_sticky: true

date: 2022-06-12
last_modified_at: 2022-06-12
---

유튜브에 있는 김덕수 교수님의 **[Operating System](https://www.youtube.com/watch?v=EdTtGv9w2sA&list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN)** 강의를 듣고 정리한 내용입니다.<br>
중간에 등장하는 ppt 내용들은 모두 강의자료를 캡처한 것입니다.
{: .notice--warning}

<br>


# 🔧 Virtual Memory

- Virtual memory
  - Non-continuous allocation
  - 사용자 프로그램을 block으로 분할하여 적재/실행
  - Paging/Segmentation system

<br>

- Virtual memory management
  - 가상 메모리 시스템 성능 최적화
  - Cost model 정의 → 다양한 최적화 기법



<br>


# 🔧 Cost model for virtual memory system

![10-4](https://user-images.githubusercontent.com/96368476/173223164-13126f07-fe14-4da8-8024-dd9d61d31e2b.png){: width="60%" height="70%" .align-center}

- Page fault rate (발생률)
- Page fault frequency (발생 빈도)
- **<span style="color:red">Page fault를 최소화 할 수 있도록 전략을 설계</span>**
  - Context swiching 및 커널 개입 최소화





<br>


# 🔧 HW Components

## Address translation device (주소 사상 장치)

- TLB, page table register, cache memory, ...

<br>

# Bit vetroes

| Bit veotrs | Reference bit 초기화 |
|:-:|:-:|
| ![10-1](https://user-images.githubusercontent.com/96368476/173223167-cbddc998-848b-4379-ac97-39a038e8203a.png) | ![10-2](https://user-images.githubusercontent.com/96368476/173223168-bb59d94c-b907-42cc-9137-129a8196f4cf.png) |

- Reference bits (참조 비트)
  - 메모리에 적재된 각각의 page가 최근에 참조되었는지 표시
  - 프로세스에 의해 참조되면 reference bit 1로 설정
  - 주기적으로 모든 reference bit 0으로 초기화
  - **어떤 방식으로 초기화하느냐가 전략**
- Update bits (갱신 비트)
  - dirty bits 라고도 함
  - page가 메모리에 적재된 후, 프로세스에 의해 수정되었는지 표시
  - 수정되었다면 memory 내의 데이터 != swap device 내의 데이터
  - **해당 page에 대한 write-back 필요**




<br>


# 🔧 SW Components

**가상 메모리 성능 향상을 위한 관리 기법들**
- Allocation strategies (할당 기법)
- Fetch strategies
- Placement strategies (배치 기법)
- Replacement strategies (교체 기법)
- Cleaning strategies (정리 기법)
- Load control strategies (부하 조절 기법)



<br>


## Allocation strategies (할당 기법)

**각 프로세스에게 얼마만큼의 메모리를 할당할 것인가?**
- Fixed allocation (고정 할당)
  - 프로세스의 실행 동안 고정된 크기의 메모리만 할당
- Variable allocation (가변 할당)
  - 프로세스 실행 동안 유동적으로 메모리 할당

<br>

- 프로세스 실행에 필요한 메모리 양을 예측해야함
- 너무 큰 메모리 할당하면 메모리 낭비
- 너무 작은 메모리 할당하면 page fault 증가


<br>


## Fetch strategies

**특정 page를 언제 메모리에 적재할 것인가?**
- Demand fetch (demand paging)
  - 프로세스가 참조하는 페이지들만 적재
  - page fault overhead
- Anticipatory fetch (pre-paging)
  - 참조될 가능성이 높은 page를 예측하고 미리 적재
  - 예측 성공 시 page fault overhead 없음
  - 예측 실패 시 자원 낭비가 큼
- 실제 대부분의 시스템은 demand fetch 기법 사용



<br>


## Placement strategies (배치 기법)

**Page/Segmentation를 어디에 적재할 것인가?**
- Paging system에는 불필요
  - 크기가 전부 같아서 전략이 필요 없음
- Segmentation system에서의 배치 기법
  - First-fit
  - Best-fit
  - Worst-fit
  - Next-fit


<br>


## Replacement strategies (교체 기법)

> 따로 빼서 정리

**빈 page frame이 없는 경우 새로운 page를 어떤 page와 교체할 것인가?**
- Fixed allocation을 위한 교체 기법
  - MIN algorithm
  - Random algorithm
  - FIFO algorithm
  - LRU(Least Recently Used) algorithm
  - LFU(Least Frequently Used) algorithm
  - NUR(Not Used Recently) algorithm
  - Clock algorithm
  - Second chance algorithm
- Variable allocation을 위한 교체 기법
  - VMIN(Variable MIN) algorithm
  - WS(Working Set) algorithm
  - PFF(Page Fault Frequency) algorithm



<br>


## Cleaning strategies (정리 기법)

**변경된 page를 언제 write-back할 것인가? (swap device에 반영)**
- Demand cleaning
  - 해당 page에 메모리에서 내려올 때 write-back
- Anticipatory cleaning (pre-cleaning)
  - 더 이상 변경될 가능성이 없다고 판단할 때 미리 write-back
  - Page 교체 시 발생하는 write-back 시간 절약
  - Write-back 이후, page 내용이 수정되면 overhead
- 실제 대부분의 시스템은 demand cleaning 기법 사용


<br>


## Load control strategies (부하 조절 기법)

![10-3](https://user-images.githubusercontent.com/96368476/173230231-c7360174-ec79-488d-a2e8-ab5858c7d884.png){: width="60%" height="70%" .align-center}

**시스템의 multi-programming degree 조절**
- Allocation strategies와 연계됨
- 저부하 상태 (Inder-loaded)
  - 시스템 자원 낭비, 성능 저하
- 고부하 상태 (Over-loaded)
  - 자원에 대한 경쟁 심화, 성능 저하
  - Thrashing(스레싱) 현상 발생
    - 과도한 page fault가 발생하는 현상



<br>


# 🔧 Replacement strategies (교체 기법)

## Locality

![10-5](https://user-images.githubusercontent.com/96368476/173231355-66bdbf0b-5b88-4f62-a830-ccb6af0c3faf.png){: width="60%" height="70%" .align-center}

- 프로세스가 프로그램/데이터의 특정 영역을 집중적으로 참조하는 현상
  - Loop structure
  - Array structure
  - 등등...
- 예시의 경우 4,7,8,6  4개의 page만을 집중적으로 접근



<br>

## Fixed allocation

### MIN algorithm (OPT algorithm)

| Replacement | Example |
|:-:|:-:|
| ![10-6](https://user-images.githubusercontent.com/96368476/173231357-06088b6a-415b-4d68-a76f-c56360d53f0e.png) | ![10-7](https://user-images.githubusercontent.com/96368476/173231358-97c74955-2c49-472d-8008-0454ecc8b38e.png) |

- 앞으로 가장 오랫동안 참조되지 않을 page 교체
- Minimize page fault frequency (Optimal solution)
  - Proved
- 실현 불가능 (Inrealizable)
  - Page reference string을 미리 알고 있어야 함
- **교체 기법의 성능 평가 도구로 사용됨**


<br>


### Random algorithm

- 무작위로 교체할 page 선택
- Low overhead
- No policy


<br>


### FIFO algorithm

| Replacement | Example |
|:-:|:-:|
| ![10-8](https://user-images.githubusercontent.com/96368476/173231360-c04b9967-9fb9-4b78-b9f3-06bd849ce1cb.png) | ![10-9](https://user-images.githubusercontent.com/96368476/173231361-1cc330a8-6a22-4c09-889f-d5e47bc77bdc.png) |

- First In First Out : 가장 오래된 page를 교체
- Page가 적재된 시간을 기억하고 있어야함
- 자주 사용되는 page가 교체될 가능성이 큼
  - Locality에 대한 고려가 없음
- FIFO anomaly
  - 더 많은 page frame을 할당 받음에도 불구하고 page fault의 수가 증가하는 경우가 있음


<br>


### LRU (Least Recently Used) algorithm

| Replacement | Example |
|:-:|:-:|
| ![10-10](https://user-images.githubusercontent.com/96368476/173232170-49e47acf-1c73-4483-b5e7-81f26ea107f1.png) | ![10-11](https://user-images.githubusercontent.com/96368476/173232171-4842df72-2413-4b01-920c-9c9f73b43601.png) |

- 가장 오랫동안 참조되지 않은 page를 교체
- Page 참조할 때마다 시간을 기록해야 함
- Locality에 기반을 둔 교체 기법
- MIN algorithm에 근접한 성능을 보여줌
- **<span style="color:red">실제로 가장 많이 활용되는 기법</span>**
- 단점
  - 참조할 때마다 시간 기록 (overhead)
    - 정확한 시간 대신 순서만 기록하는 등 간소화 가능
  - Loop 실행에 필요한 크기보다 작은 수의 page frame이 할당 된 경우, page fault 수가 급격히 증가
    - Allocation 기법으로 해결해야 함



<br>


### LFU (Least Frequently Used) algorithm

| Replacement | Example |
|:-:|:-:|
| ![10-12](https://user-images.githubusercontent.com/96368476/173232172-c50d3f43-28fe-43e4-b6c2-f159c061e6ae.png) | ![10-13](https://user-images.githubusercontent.com/96368476/173232173-45c72433-a4ed-4d28-8244-afcadad542e3.png) |

- 참조 횟수가 가장 적은  page를 교체
- Page 참조할 때마다 참조 횟수를 누적시켜야 함
  - LRU 대비 적은 overhead
- 단점 : 최근 적재된 참조될 가능성이 높은 page가 교체될 수 있음



<br>


### NUR (Not Used Recently) algorithm

![10-14](https://user-images.githubusercontent.com/96368476/173232174-090cd3db-b094-4da3-a1f0-b9b9bee08eaa.png){: width="60%" height="70%" .align-center}

- LRU와 비슷
  - 시간이 아닌 참조 여부만 다짐
  - LRU보다 적은 overhead & 비슷한 성능
- **Bit vector 사용하면 편함!**



<br>


### Clock algorithm

| Replacement | Example |
|:-:|:-:|
| ![10-12](https://user-images.githubusercontent.com/96368476/173232172-c50d3f43-28fe-43e4-b6c2-f159c061e6ae.png) | ![10-13](https://user-images.githubusercontent.com/96368476/173232173-45c72433-a4ed-4d28-8244-afcadad542e3.png) |






<br>




[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}