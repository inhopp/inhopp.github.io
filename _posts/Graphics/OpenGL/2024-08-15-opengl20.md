---
title:  "Shadow (1)"

categories:
  -  OpenGL
tags:
  - [Graphics]

toc: true
toc_sticky: true

date: 2024-08-15
last_modified_at: 2024-08-15
---


**Main Reference <br>- [Learn OpenGL](https://learnopengl.com/) <br>- [Rinthel Kwon - OpenGL Lecture](https://www.youtube.com/watch?v=kEAKvJKnvfA&list=PLvNHCGtd4kh_cYLKMP_E-jwF3YKpDP4hf&index=1)**
{: .notice--warning}

<br>

# Shadow Mapping

![Ect-68](https://github.com/inhopp/StyleGAN/assets/96368476/c90364e7-6f95-4a3f-8ee8-dd97ec2d560a){: width="40%" height="50%"}

Shadow Mapping은 그림자 구현에 가장 많이 사용되는 알고리듬 기법이다. 구현 난이도가 어렵지 않으며, 고급 알고리듬으로 확장하기도 용이하다. 대략적인 구현 방법은 다음과 같다.

- Light를 기준으로 Depth Map 구하기 (Shadow Map)
- 실제 렌더링되는 특정 픽셀의 world position과 light 사이의 거리 구하기
- 두 값을 비교하여 그림자 영역 판별

<br>

# Shadow Map - First Pass

``` c++
CLASS_PTR(ShadowMap);
class ShadowMap {
public:
    static ShadowMapUPtr Create(int width, int height);
    ~ShadowMap();

    const uint32_t Get() const { return m_framebuffer; }
    void Bind() const;
    const TexturePtr GetShadowMap() const { return m_shadowMap; }

private:
    ShadowMap() {}
    bool Init(int width, int height);

    uint32_t m_framebuffer { 0 };
    TexturePtr m_shadowMap;
};
```

- ShadowMap 클래스의 구조는 FrameBuffer와 유사하다.
- `m_framebuffer` : shadow map을 렌더링하기 위해 사용하는 framebuffer
- `m_shadowMap` : 렌더링 결과를 저장할 텍스처

<br>

``` c++
bool ShadowMap::Init(int width, int height) {
    glGenFramebuffers(1, &m_framebuffer);
    Bind();

    m_shadowMap = Texture::Create(width, height, GL_DEPTH_COMPONENT, GL_FLOAT);
    m_shadowMap->SetFilter(GL_NEAREST, GL_NEAREST);
    m_shadowMap->SetWrap(GL_CLAMP_TO_BORDER, GL_CLAMP_TO_BORDER);
    m_shadowMap->SetBorderColor(glm::vec4(1.0f));

    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
        GL_TEXTURE_2D, m_shadowMap->Get(), 0);
    glDrawBuffer(GL_NONE);
    glReadBuffer(GL_NONE);
    auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE) {
        SPDLOG_ERROR("failed to complete shadow map framebuffer: {:x}", status);
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        return false;
    }
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    return true;
}
```

Shadow Map 클래스의 전체적인 구조는 Frame Buffer와 유사하지만, 구체적인 구현 과정에서는 몇몇 차이가 존재한다.

- `m_shadowMap = Texture::Create(width, height, GL_DEPTH_COMPONENT, GL_FLOAT);`
    - 우선 shadow map 텍스처를 생성할 때 일반적인 텍스처와 세팅 값이 다르다.
    - 단순 Depth Map 텍스처 이므로 RGBA 8bit가 아닌 단일채널 32bit flaot 으로 생성하기 때문
    - GL_RGB format에서 GL_DEPTH_COMPONENT로 변경
    - GL_UNSIGNED_BYTE type에서 GL_FLOAT으로 변경
- `glDrawBuffer(GL_NONE)`, `glReadBuffer(GL_NONE)`
    - OpenGL에게 color attachment가 없음을 명시적으로 알려줘야 함
    - 그래야 glCheckFramebufferStatus 함수 통과

<br>

``` c++
// Render()..

ImGui::Image((ImTextureID)m_shadowMap->GetShadowMap()->Get(),
            ImVec2(256, 256), ImVec2(0, 1), ImVec2(1, 0));

// ...

auto lightView = glm::lookAt(m_light.position, m_light.position + m_light.direction, glm::vec3(0.0f, 1.0f, 0.0f));
auto lightProjection = glm::perspective(glm::radians((m_light.cutoff[0] + m_light.cutoff[1]) * 2.0f), 1.0f, 1.0f, 20.0f);

m_shadowMap->Bind();
glClear(GL_DEPTH_BUFFER_BIT);
glViewport(0, 0,
    m_shadowMap->GetShadowMap()->GetWidth(),
    m_shadowMap->GetShadowMap()->GetHeight());
m_simpleProgram->Use();
m_simpleProgram->SetUniform("color", glm::vec4(1.0f, 1.0f, 1.0f, 1.0f));
DrawScene(lightView, lightProjection, m_simpleProgram.get());

Framebuffer::BindToDefault();
glViewport(0, 0, m_width, m_height);
```

- ImGUI를 통해 shadow map 텍스처 확인용 visualize 설정
- Light의 입장에서 depth map을 그려야 하기 때문에 camera view, projection이 아닌 light view, projection 세팅
- 이때 주의할 점은 shadow map의 해상도와 실제 렌더링되는 frame buffer의 해상도가 다를 수 있기 때문에 viewport 알맞게 지정

<br>

## Result

![045942](https://github.com/user-attachments/assets/bc558d23-d588-489e-816a-47237acef845)

Float32 단일 채널로 텍스처를 지정했기 때문에 depth 값이 커질수록 빨간색으로 표현됨


<br>
<br>


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}