---
title:  "Lighting" 

categories:
  -  Graphics
tags:
  - [DirectX]

toc: true
toc_sticky: true

date: 2023-07-24
last_modified_at: 2023-07-24
---


í™ì •ëª¨ë‹˜ì˜ **[ê·¸ë˜í”½ìŠ¤ ìƒˆì‹¹ì½”ìŠ¤](https://honglab.co.kr/)** ê°•ì˜ë¥¼ ë“£ê³  ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.
{: .notice--warning}

<br>


# ğŸ¥ Object Rotation vs View Rotation

| Object | View |
|:-:|:-:|
|![ezgif com-crop (2)](https://github.com/inhopp/inhopp/assets/96368476/63098a46-54de-464e-a774-dfa637af0588)|![ezgif com-crop (1)](https://github.com/inhopp/inhopp/assets/96368476/4ccd7945-229e-40b9-b2f0-24ba9629d25b)
| 


<br>


# ğŸ¥ Shader Code

> Vertex Bufferì—ëŠ” normalë³€í™˜ì„ ìœ„í•œ inverse_transposeë„ í•„ìš”

``` cpp
// Vertex Buffer
cbuffer VertexConstantBuffer : register(b0)
{
    matrix model;
    matrix invTranspose;
    matrix view;
    matrix projection;
};
```

<br>

> íŠ¹ì´í•œ ë¶€ë¶„

``` cpp
// In Pixel Shader
[unroll] 
for (i = 0; i < NUM_DIR_LIGHTS; ++i)
{
    color += ComputeDirectionalLight(lights[i], material, input.normalWorld, toEye);
}

[unroll]
for (i = NUM_DIR_LIGHTS; i < NUM_DIR_LIGHTS + NUM_POINT_LIGHTS; ++i)
{
    color += ComputePointLight(lights[i], material, input.posWorld, input.normalWorld, toEye);
}

[unroll]
for (i = NUM_DIR_LIGHTS + NUM_POINT_LIGHTS; i < NUM_DIR_LIGHTS + NUM_POINT_LIGHTS + NUM_SPOT_LIGHTS; ++i)
{
    color += ComputeSpotLight(lights[i], material, input.posWorld, input.normalWorld, toEye);
}
```

- Shader ë‚´ì—ì„œ ë¶„ê¸°ë¬¸ì€ ì•ˆì“°ëŠ”ê²Œ ì¢‹ìŒ (serializeë¨)
- lightì˜ ê²½ìš° directional/point/spot ì¤‘ í•˜ë‚˜
- shaderì—ì„œ if/else ì“°ëŠ” ë°©ì‹ì´ ì•„ë‹Œ ì „ë¶€ ì‹¤í–‰
    - ê·¸ ëŒ€ì‹  cpuì—ì„œ light_strength = 0 ì§€ì •



<br>



# ğŸ¥ Results

![ezgif com-crop (3)](https://github.com/inhopp/inhopp/assets/96368476/a67a44df-1de4-4ed0-8267-82b08be8ae63)

<br>
<br>


[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}