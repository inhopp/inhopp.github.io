---
title:  "Clouds Rendering" 

categories:
  -  Graphics
tags:
  - [DirectX]

toc: true
toc_sticky: true

date: 2024-11-19
last_modified_at: 2024-11-19
---


홍정모님의 **[그래픽스 새싹코스](https://honglab.co.kr/)** 강의를 듣고 정리한 내용입니다.
{: .notice--warning}

**Other References: <br>[How Big Budget AAA Games Render Clouds - SimonDev](https://www.youtube.com/watch?v=Qj_tK_mdRcA&t=525s)**
{: .notice--primary}

# Fog vs Clouds

| Fog | Beer's Law | Cloud |
|:-:|:-:|:-:|
|![205537](https://github.com/user-attachments/assets/df87220c-ff09-41d5-acab-a37896fc050e)|![203320](https://github.com/user-attachments/assets/e91d6584-1629-4662-89bf-6433e9a4e793)| ![205607](https://github.com/user-attachments/assets/e65c3f92-19bb-4d7b-967a-96b4a487de49)|


이전 포스팅에서 배운 Fog Effect의 경우, 거리에 따라 밝기를 감쇠시킴으로서 구현할 수 있었다. 하지만 Cloud 혹은 Cloud-like object는 같은 방식으로 구현할 수 없다. Boundary가 존재하고, 내부 밀도가 일정하지 않으며, position에 따른 lighting 계산도 해야하기 때문이다. 이번 예제에서는 Object의 Density와 Lighting 정보를 따로 계산해 3D-Texture에 저장해두고 사용할 것이다. 이러한 방식을 이용하면 여러가지 장점이 있다. 먼저 pixel shader에서 interpolation 연산을 진행할 때 중복 연산을 피할 수 있다. 또한 실제 object의 크기보다 작은 texture를 이용해 최적화 할 수 있다는 것도 큰 장점이다.

<br>

# Density Map

| Cloud | Absorption |
|:-:|:-:|
|![203307](https://github.com/user-attachments/assets/a5d1b024-0c95-41dd-96b2-a8afcd46847f)|![204336](https://github.com/user-attachments/assets/93c3a707-4729-4fb5-b8cd-fc1ebd050702)|

``` hlsl
void main(uint3 dtID : SV_DispatchThreadID)
{
    uint width, height, depth;
    densityTex.GetDimensions(width, height, depth);
    
    float3 uvw = dtID / float3(width, height, depth) + uvwOffset;

    densityTex[dtID] = cloudDensity(uvw);
}
```

- Perlin-Worley noise를 이용해 Density Map 생성
- Absorption(감쇠) 연산은 object를 step으로 쪼갠 뒤, (Beer's law * step size) 적용
- `uvwOffset`을 이용해 구름이 흘러가는 연출 구현

<br>

# Lighting Map


<br>


<br>
<br>


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}