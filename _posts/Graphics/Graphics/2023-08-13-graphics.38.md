---
title:  "Shader Toy - Planet" 

categories:
  -  Graphics
tags:
  - [DirectX]

toc: true
toc_sticky: true

date: 2023-08-13
last_modified_at: 2023-08-13
---

í™ì •ëª¨ë‹˜ì˜ **[ê·¸ë˜í”½ìŠ¤ ìƒˆì‹¹ì½”ìŠ¤](https://honglab.co.kr/)** ê°•ì˜ë¥¼ ë“£ê³  ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤. <br>**[Shadertoy](https://www.shadertoy.com/view/lt3XDM)** ì˜ glsl ì½”ë“œë¥¼ hlslë¡œ ë§¤í•‘í•œ ì½”ë“œì…ë‹ˆë‹¤.
{: .notice--warning}

<br>


# ğŸ¥ Render Planet

``` hlsl
float fbm(float3 x, float OCTAVES) { 
    float v = 0.0;
    float a = 0.5;
    float3 shift = float3(100, 100, 100);

    for (int i=0; i<OCTAVES; ++i) {
        v += a * noise(x);
        x = x * 2.0 + shift;
        a *= 0.5;
    }

    return v;
}

// ...


Material planetMaterial;

// X : input.position
X = mul(planetRotation, (X - planetCenter));
float3 surfaceLocation = normalize(X);

float mountain = clamp(1.0 - fbm(surfaceLocation * 4.0, 6) + (max(abs(surfaceLocation.y) - 0.6, 0.0)) * 0.03, 0.0, 1.0);
mountain = pow(mountain, 3) * 0.25 + 0.8;

const float water = 0.85;
float elevation = mountain;

float3 normal = normalize(cross(ddx(surfaceLocation * mountain), ddy(surfaceLocation * mountain)));
```

ì½”ë“œë¥¼ ë³´ë©´ ìš°ì„  êµ¬ í˜•íƒœë¥¼ ì¡ì€ ë’¤ FBM(Fractal Brownian Motion)ì„ ì´ìš©í•´ ì§€í˜•ì„ ìƒì„±í•œë‹¤. FBMì„ ì™„ì „íˆ ì´í•´í•˜ì§€ ëª»í–ˆì§€ë§Œ ìì—°ì—ì„œ ë°œìƒí•˜ëŠ” ìì—° ì¹¨ì‹ì„ ë…¸ì´ì¦ˆì™€ í”„ë™íƒˆì„ ì´ìš©í•˜ì—¬ êµ¬í˜„í•œ ê²ƒì´ë¼ê³  í•œë‹¤.

<br>

``` hlsl
static const Material ROCK = {float3(0.5, 0.35, 0.15), 0.0, 0.0};
static const Material TREE = {float3(0.05, 1.15, 0.10), 0.2, 0.1};
static const Material SAND = {float3(1.0, 1.0, 0.85), 0.0, 0.0};
static const Material ICE = {float3(0.85, 1.00, 1.20), 0.2, 0.6};

// ...

float materialNoise = noise(surfaceLocation * 200.0);

float slope =
    clamp(2.0 * (1.0 - dot(normal, surfaceLocation)), 0.0, 1.0);

bool iceCap = abs(surfaceLocation.y) + materialNoise * 0.2 > 0.98;
bool rock =
    (elevation + materialNoise * 0.1 > 0.94) || (slope > 0.3);
bool mountainTop = (elevation + materialNoise * 0.05 -
                    slope * 0.05) > (planetMaxRadius * 0.92);

bool sand = (elevation < water + 0.006) &&
            (noise(surfaceLocation * 8.0) > 0.3);

sand = sand || (elevation < 0.89) &&
                    (noise(surfaceLocation * 1.5) * 0.15 +
                        noise(surfaceLocation * 73.0) * 0.25 >
                    abs(surfaceLocation.y));

if (rock) {
    planetMaterial = ROCK;
} else {
    planetMaterial = TREE;
}

if (iceCap || mountainTop) {
    planetMaterial = ICE;
} else if (!rock && sand) {
    planetMaterial = SAND;
} else if (!rock && (iResolution.x > 420.0)) {
    elevation += noise(surfaceLocation * 150.0) * 0.02;
}

if (!sand && !iceCap) {
    planetMaterial.color *=
        lerp(noise(surfaceLocation * 256.0), 1.0, 0.4);
}
```

Materialì„ ì •ì˜í•œ ë’¤ ìƒì„±ëœ ì§€í˜•ì„ ì ì ˆíˆ ë¶„ë°°í•œë‹¤. ê¸°ë³¸ base materialì€ ë¬¼ì´ê³ , ì‚° ê¼­ëŒ€ê¸°ë¥¼ iceì²˜ë¦¬í•œ ë””í…Œì¼ì´ ì¸ìƒì ì´ë‹¤.

<br>

![1](https://github.com/inhopp/inhopp/assets/96368476/24deff0e-4670-4bee-a87c-cfc2ee5989b7){: width="60%" height="70%"}


<br>

``` hlsl
if (elevation < water) {
    float relativeWaterDepth = min(1.0, (water - mountain) * 30.0);
    const float waveMagnitude = 0.0014;
    const float waveLength = 0.01;

    const float3 shallowWaterColor = float3(0.4, 1.0, 1.9);
    const float shallowWaveRefraction = 4.0;
    float shallowWavePhase =
        (surfaceLocation.y - mountain * shallowWaveRefraction) *
        (1.0 / waveLength);

    const float3 deepWaterColor = float3(0.0, 0.1, 0.7);
    float deepWavePhase = (atan2(surfaceLocation.x, surfaceLocation.z) +
                            noise(surfaceLocation * 15.0) * 0.075) *
                            (1.5 / waveLength);

    float wave = (cos(shallowWavePhase + iTime * 1.5) *
                        sqrt(1.0 - relativeWaterDepth) +
                    cos(deepWavePhase + iTime * 2.0) * 2.5 *
                        (1.0 - abs(surfaceLocation.y)) *
                        pow(relativeWaterDepth, 2)) *
                    waveMagnitude;

    elevation = water + wave;
}
```

ì´ì œ íŒŒë„ë¥¼ ì¶”ê°€í•´ì£¼ê³  (deep water, shallow water êµ¬ë¶„í•´ì£¼ëŠ” ê¹¨ì•Œ ë””í…Œì¼..)<br>
Ray tracingì„ ì´ìš©í•´ ì „ì—­ ì¡°ëª…(direct + indirect) + ê·¸ë¦¼ìê¹Œì§€ ì¶”ê°€í•´ì¤€ë‹¤.

<br>

| Before | After |
|:-:|:-:|
|![2](https://github.com/inhopp/inhopp/assets/96368476/24deff0e-4670-4bee-a87c-cfc2ee5989b7)|![3](https://github.com/inhopp/inhopp/assets/96368476/5aad8a59-d01e-41ef-ab87-b603a86c6297)| 


<br>

![ezgif com-crop (5)](https://github.com/inhopp/inhopp/assets/96368476/dc9f019e-122e-478a-87ad-952b4a1569ee)

> ëŒ€ê¸° ëº€ ì˜ìƒìœ¼ë¡œ ìˆ˜ì •í•˜ê¸°


<br>



# ğŸ¥ Render Background

``` hlsl
// Background starfield
float galaxyClump =
    (pow(noise(input.position.xy * (30.0 * invResolution.x)), 3.0) *
            0.5 +
        pow(noise(100.0 + input.position.xy * (15.0 * invResolution.x)),
            5.0)) /
    1.5;

float L_o_color =
    galaxyClump * pow(hash(input.position.xy), 1500.0) * 80.0;
L_o = float3(L_o_color, L_o_color, L_o_color);

// Color stars
L_o.r *= sqrt(noise(input.position.xy) * 1.2);
L_o.g *= sqrt(noise(input.position.xy * 4.0));

// Twinkle
L_o *= noise(iTime * 0.5 + input.position.yx * 10.0);
float2 delta =
    (input.position.xy - iResolution.xy * 0.5) * invResolution.y * 1.2; // strength
float atmosphereRadialAttenuation =
    min(1.0, 0.06 * pow(max(0.0, 1.0 - (length(delta) - 0.9) / 0.9), 8));

// Gradient around planet
float radialNoise =
    lerp(1.0, noise(normalize(delta) * 40.0 + iTime * 0.5), 0.14);
L_o += radialNoise * atmosphereRadialAttenuation * shadowedAtmosphere;

return float4(L_o, maxDistanceToPlanet);
```

- ë°°ê²½ ì •ë„ëŠ” textureë¥¼ ì‚¬ìš©í•  ë²• í•œë°, ë³„ í•˜ë‚˜í•˜ë‚˜ë¥¼ noiseë¡œ ì§ì ‘ êµ¬í˜„í–ˆë‹¤! 

<br>


> ë°°ê²½ ì‚¬ì§„



<br>


![ezgif com-crop (6)](https://github.com/inhopp/inhopp/assets/96368476/46f99e59-5aff-4293-b217-15a2390d295c)



<br>


# ğŸ¥ Render Clouds

``` hlsl
float4 renderClouds(Ray eyeRay, float minDist, float maxDist,
                       float3 shadowedAtmosphere) {
    const int maxSteps = 80;
    const float stepSize = 0.012;
    const float3 cloudColor = float3(0.95, 0.95, 0.95);
    const float3 ambient = float3(0.9, 1.0, 1.0);

    float planetShadow = clamp(
        0.4 + dot(w_i, normalize(eyeRay.origin + eyeRay.direction * minDist)),
        0.25, 1.0);

    float4 result = float4(0.0, 0.0, 0.0, 0.0);

    float t = maxDist;
    for (int i = 0; i < maxSteps; ++i) {
        if (t > minDist) {
            float3 X = ((eyeRay.direction * t + eyeRay.origin) - planetCenter) *
                       (1.0 / planetMaxRadius);

            float density = cloudDensity(X, iTime);

            if (density > 0.0) {
                const float eps = stepSize;
                float wrapShading =
                    clamp(-(cloudDensity(X + w_i * eps, iTime) - density) *
                              (1.0 / eps),
                          -1.0, 1.0) *
                        0.5 +
                    0.5;

                float AO = pow((dot(X, X) - 0.5) * 2.0, 8);
                float3 L_o = cloudColor * (B_i * planetShadow * wrapShading *
                                                  lerp(1.0, AO, 0.5) +
                                              ambient * AO);

                L_o = lerp(L_o, shadowedAtmosphere,
                          min(0.5, pow(max(0.0, 1.0 - X.z), 2)));

                density *= pow(
                    1.0 - abs(2.0 * length(X - planetCenter) -
                              (cloudMinRadius + planetMaxRadius)) *
                              (1.0 / (planetMaxRadius - cloudMinRadius)), 2);

                result = lerp(result, float4(L_o, 1.0), density);

                t += stepSize * 2.0;
            }

            t -= stepSize * 3.0;
        } else {
            return result;
        }
    }

    return result;
}
```

![4](https://github.com/inhopp/inhopp/assets/96368476/e89e42a4-a39e-4418-bc68-dc1897d22d6b){: width="50%" height="60%"}

Cloud ì½”ë“œëŠ” ë´ë„ ì´í•´ë¥¼ ëª» í•˜ê² ë„¤ìš”.. ì´ ë¶€ë¶„ ì—­ì‹œ fbmì„ ì´ìš©í•˜ë˜ë° ì¢€ ë” ë‚´ê³µì„ ìŒ“ê³  ì™€ì•¼ê² ìŠµë‹ˆë‹¤.

<br>

## Combine Planet and Clouds

![5](https://github.com/inhopp/inhopp/assets/96368476/ec0d4c13-b236-4e44-91ba-21559593b1cd){: width="60%" height="70%"}


<br>



# ğŸ¥ Blurring

![6](https://github.com/inhopp/inhopp/assets/96368476/3b0d2d52-0e6d-4f94-b6fb-382fc88282c7){: width="60%" height="70%"}

> ì˜ìƒìœ¼ë¡œ êµì²´í•˜ê¸°

- ë§ˆì§€ë§‰ìœ¼ë¡œ blurring í•´ì¤€ ê²°ê³¼! ì•„ë¦„ë‹µë‹¤ ì•„ë¦…ë‹¤ì›Œ~


<br>


# ğŸ¥ Epilogue

ë Œë”ë§ íŒŒì´í”„ë¼ì¸ ì—´ì‹¬íˆ ê³µë¶€í•˜ê³  ê³ ë¥¸ ì˜ˆì œê°€ í•˜í•„ Ray tracingìœ¼ë¡œ êµ¬í˜„í•œ ì˜ˆì œì˜€ë‹¤. ëª¨ë¸ì„ shaderì—ì„œ ë§Œë“¤ê³ , ëª¨ë¸ì˜ íšŒì „ë“±ì„ ëª¨ë‘ gpuì—ì„œ ì²˜ë¦¬í•œë‹¤. ì²˜ìŒì—ëŠ” "WebGLì„ ì´ìš©í•œ ì˜ˆì œì—¬ì„œ ê·¸ëŸ°ê°€??" í•˜ê³  ë‚´ê°€ ë°°ìš´ ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì— ë§ê²Œ ìˆ˜ì •í•˜ë ¤ê³  í–ˆì—ˆë‹¤. ë§‰ìƒ í•˜ë ¤ë‹ˆ 'ì–´ì°¨í”¼ í”½ì…€ë§ˆë‹¤ rayë¥¼ ì˜ì•„ì•¼ í•˜ëŠ”ë° êµ³ì´ vertex, index ë§Œë“¤ê³  raserizationê¹Œì§€ í•´ì•¼í•´..?'í•˜ê³  ê¹¨ë‹¬ì•„ë²„ë ¸ë‹¤! ray tracingì€ í›„ì²˜ë¦¬ ì‘ì—…ì´ë¼ëŠ” ê²ƒì„..
ë§‰ìƒ ì ê³ ë‚˜ë‹ˆ ë‹¹ì—°í•œ ì´ì•¼ê¸°ì²˜ëŸ¼ ë“¤ë¦¬ë„¤ã… ã…  <br> ì•„ë¬´íŠ¼ ì´ë²ˆ ì˜ˆì œë¥¼ í•˜ë©° ëŠë‚€ ì ì€ ê·¸ë˜í”½ìŠ¤ ì •ë§ ë©‹ì§€ë‹¤! ê·¼ë° ë¹Œë“œ í•œë²ˆ í•˜ëŠ”ë° 3~5ë¶„ì”© ê±¸ë¦¬ë‹ˆ ì •ë§ ëª»í•´ë¨¹ê² ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤. ê·¸ë¦¬ê³  ê°€ì¥ ì˜ˆë» ë³´ì´ëŠ” ì˜ˆì œë¥¼ ê³¨ëëŠ”ë°, ê³ ë¥´ê³  ë‚˜ë‹ˆ ray tracing, multipass rendering, í›„ì²˜ë¦¬ í•„í„°ê¹Œì§€ í¬í•¨ëœ ì™„ë²½í•œ ì˜ˆì œì˜€ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤. 






<br>
<br>


[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}